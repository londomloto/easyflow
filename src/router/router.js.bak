
(function(){

    var Router = Graph.router.Router = Graph.extend({

        props: {
            type: 'router',
            command: 'M 0 0 L 0 0',
            segments: [['M', 0, 0], ['L', 0, 0]]
        },

        ports: {
            source: null,
            target: null
        },

        paper: null,

        constructor: function(paper, source, target, options) {
            _.extend(this.props, options || {});

            this.paper = paper;
            this.ports.source = source;
            this.ports.target = target;

            var segments = this.props.segments,
                spoint = source ? source.location() : null,
                tpoint = target ? target.location() : null;

            if (spoint) {
                segments[0][1] = spoint.props.x;
                segments[0][2] = spoint.props.y;
            }

            if (tpoint) {
                segments[1][1] = tpoint.props.x;
                segments[1][2] = tpoint.props.y;
            }

            this.commit();
        },

        source: function(source) {
            if (_.isUndefined(source)) {
                return this.ports.source;
            }

            this.ports.source = source;

            var segments = this.props.segments, 
                spoint = source ? source.location() : null;

            if (spoint) {
                segments[0][1] = spoint.props.x;
                segments[0][2] = spoint.props.y;
                this.commit();
            }

            return this;
        },

        target: function(target) {
            if (_.isUndefined(target)) {
                return this.ports.target;
            }
            
            this.ports.target = target;

            var segments = this.props.segments, 
                maxs = segments.length - 1,
                tpoint = target ? target.location() : null;

            if (tpoint) {
                segments[maxs][1] = tpoint.props.x;
                segments[maxs][2] = tpoint.props.y;
                this.commit();
            }

            return this;
        },

        command: function() {
            return this.props.command;
        },

        segments: function() {
            return this.props.segments;
        },

        start: function() {
            var segments = this.props.segments, 
                maxs = segments.length - 1;
            return Graph.point(segments[maxs][1], segments[maxs][2]);
        },

        end: function() {
            var segments = this.props.segments;
            return Graph.point(segments[0][1], segments[0][2]);
        },

        supply: function(command) {
            this.props.command  = command;
            this.props.segments = Graph.util.path2segments(command);
            return this;
        },

        route: function() {
            return this;
        },

        patch: function() {
            return this;
        },

        modify: function() {
            return this;
        },

        insert: function() {
            return this;
        },

        commit: function() {
            this.props.command = Graph.util.segments2path(this.props.segments);
            return this;
        },

        tidify: function() {
            return this;
        },

        parse: function(json) {
            
        }
    });

    ///////// STATICS /////////
    
    Router.dirangle = function(x1, y1, x2, y2, dirs) {
        var sectors;
        if (x1 instanceof Graph.lang.Point) {
            sectors = 360 / x2;
            return Math.floor((x1.theta(y1) + sectors / 2) / sectors) * sectors;
        } else {
            sectors = 360 / dirs;
            return Math.floor((Graph.math.theta(x1, y1, x2, y2) + sectors / 2) / sectors) * sectors;
        }
    };

    Router.dirorient = function(x1, y1, x2, y2, dirs) {
        var angle = Router.dirangle(x1, y1, x2, y2, dirs);
        return [0, 180, 360].indexOf(angle) !== -1 ? 'H' : ([90, 270].indexOf(angle) !== -1 ? 'V' : null);
    };

    Router.dirchange = function(angle1, angle2) {
        var delta = Math.abs(angle1 - angle2);
        return delta > 180 ? 360 - delta : delta;
    };

    ///////// UTIL HEAP /////////
    Router.util = {};

    Router.util.Heap = Graph.extend({

        items: [],
        state: {},
        costs: {},

        constructor: function() {},

        add: function(key, value) {
            var me = this, insert;

            if (me.state[key]) {
                me.items.splice(me.items.indexOf(key), 1);
            } else {
                me.state[key] = 'OPEN';
            }

            me.costs[key] = value;

            insert = _.sortedIndexBy(me.items, key, function(k){
                return me.costs[k];
            });

            this.items.splice(insert, 0, key);
        },

        has: function(key) {
            return !!this.state[key];
        },

        remove: function(key) {
            this.state[key] = 'CLOSE';
        },

        isOpen: function(key) {
            return this.state[key] == 'OPEN';
        },

        isClose: function(key) {
            return this.state[key] == 'CLOSE';  
        },

        isEmpty: function() {
            return this.items.length === 0;
        },

        pop: function() {
            var key = this.items.shift();
            this.remove(key);
            return key;
        }
    });

}());